W. Xu, H. Moon, S. Kashyap, P. Tseng and T. Kim, "Fuzzing File Systems via Two-Dimensional Input Space Exploration," 2019 IEEE Symposium on Security and Privacy (SP), 2019, pp. 818-834, doi: 10.1109/SP.2019.00035.

SUMMARY: File systems are one of the most basic services of an OS. Most conventional file systems run in the kernel, and hence can lead to devastating errors when bugs are found. However, file systems are large and complex, and coventional stress-testing frameworks either do not scale well (i.e., model checking) or only consider file system regression. Fuzz testing of file systems is gaining traction, but file systems present unique challenges that differ from typical binary fuzzing. Namely, fuzzing a file system consists of mutating a mounted disk image and a program that makes file operations on that image. In this paper, the authors propose Janus, an evolutionary feedback-driven file system fuzzer. When mutating a seed disk image, Janus only mutates the metadata blocks of the image, which reduces the search space of the input. When mutating the file ops program, Janus uses an image-directed syscall fuzzing technique, i.e., it stores generated system calls on file objects and tracks their runtime status after each system call is executed. Moreover, Janus utilizes a libOS executor, i.e., Linux Kernel Library, as opposed to a VM for mounting an image and executing the program; this improves performance and enhances bug reproducibility. Janus found 90 bugs, including 32 CVEs, across 8 popular Linux file systems.

<hr/>

H. Peng, Y. Shoshitaishvili and M. Payer, "T-Fuzz: Fuzzing by Program Transformation," 2018 IEEE Symposium on Security and Privacy (SP), 2018, pp. 697-710, doi: 10.1109/SP.2018.00056.

SUMMARY: Mutational fuzzing is limited by its coverage. Programs may contain complex sanity checks, e.g., checksums, hashes, or magic values, which severely limit code coverage. In this paper, the authors propose Transformational Fuzzing, and a prototype called T-Fuzz. When the fuzzer gets stuck on some sanity check in the program, the fuzzer invokes a program transformer that detects and removes the sanity check from the program. This allows the fuzzer to explore the code paths that were previously protected by those checks. If bugs are found, then a post-processing symbolic execution-based analysis is used which removes false positives. T-Fuzz found bugs in 166 binaries out of 296 in the DARPA CGC dataset, and it found 3 new bugs in real-world applications.

<hr/>

W. You et al., "ProFuzzer: On-the-fly Input Type Probing for Better Zero-Day Vulnerability Discovery," 2019 IEEE Symposium on Security and Privacy (SP), 2019, pp. 769-786, doi: 10.1109/SP.2019.00057.

SUMMARY: Generation-based fuzzing relies on a grammar describing input formats to produce legimite test cases. On the one hand, this reduces the search space for crafting inputs. On the other hand, the grammar must be supplied beforehand or executed from input traces, and vulnerable inputs may not follow the grammar if an implementation ignores certain fields. Meanwhile, mutation-based fuzzing requires seed inputs, requiring no grammar; however, mutation is typically random. In this paper, this authors propose ProFuzzer, which uses a lightweight fuzzing procedure called probing that guides evolution of seed inputs. Specifically, the fuzzer executes in two stages: 1) bytes are sequentially changed one at a time to test the execution path against different values, and data fields are recovered; 2) the fuzzer mutates each field to increase coverage and exploit bad field values. The authors define six application-agnostic field types: 1) assertion (magic byte); 2) raw data (does not affect program execution); 3) enumeration (small set of valid values); 4) loop count (number of times a loop structure executes); 5) offset (locate in the input where the program can access data); 6) size (the size of data to read). ProFuzzer found 42 zero-days among 10 programs, generating 30 CVEs.

<hr/>

S. Gan et al., "CollAFL: Path Sensitive Fuzzing," 2018 IEEE Symposium on Security and Privacy (SP), 2018, pp. 679-696, doi: 10.1109/SP.2018.00040.

SUMMARY: Popular coverage-guided fuzzers suffer from two issues. First, in fuzzers which track edge coverage, edge collisions are a known problem due to the way that edge coverage is calculated; in some applications, up to 75% of edges may collide with others. Second, fuzzers rarely utilize code coverage information to directly drive fuzzing towards non-explored paths. In this paper, the authors propose CollAFL, which rectifies these issues. To solve the edge collision problem, CollAFL analyzes the control flow graph of the application to get a list of known edges, and employs a edge hash scheme with low instrumentation cost and zero collisions. To target non-explored paths, CollAFL proposes three new seed selection policies: 1) untouched-neighbor-branch guided (prioritize seeds with more untouched neighbors); 2) untouched-neighbor-descendant guided (prioritize seeds with untouched neighbors that have more descendants); 3) memory-access guided policy (prioritize seeds with more memory access operations). When compared to AFL, CollAFL covered 20% more program paths, 320% more unique crashes, and 260% more bugs in the LAVA-M dataset. CollAFL also found 157 bugs in 24 applications, generating 95 CVEs.

<hr/>

P. Chen and H. Chen, "Angora: Efficient Fuzzing by Principled Search," 2018 IEEE Symposium on Security and Privacy (SP), 2018, pp. 711-725, doi: 10.1109/SP.2018.00046.

SUMMARY: Symbolic execution is slow and cannot solve many types of constraints efficiently. Coverage-based fuzzers may avoid symbolic execution by instrumenting the program to observe which inputs explore new program paths. However, most inputs are ineffective because they do not consider the data flow of the program. In this paper, the authors propose Angora, a fuzzer that solves path constraints without using symbolic execution. Angora uses context-sensitive branch counting (e.g., multiple executions of the same branch are counted independently) to observe new internal states of the program. Furthermore, Angora uses byte-level taint tracking to identify which byte offsets in the input affect the branch outcome. Due to the high resource cost of taint tracking, Angora only runs taint tracking on an input once to record the interesting byte offsets. To decide how to mutate an input effectively, Angora frames the mutation function as a search problem and adopts gradient descent to iteratively search for a solution to the constraint. To avoid problems in gradient descent due to type mismatch, Angora uses dynamic taint analysis to infer the shape (which bytes are always used together as a single value) and type of bytes in the input. Finally, Angora uses dynamic taint tracking to track when a read call gets all the bytes it requires, which can enable exploration of paths with input length requirements. Angora outperformed state-of-the-art fuzzers by finding the most bugs in the LAVA-M data set. Angora also found 205 new bugs in 8 popular open source programs.

<hr/>
