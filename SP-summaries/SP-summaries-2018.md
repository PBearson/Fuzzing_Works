W. Xu, H. Moon, S. Kashyap, P. Tseng and T. Kim, "Fuzzing File Systems via Two-Dimensional Input Space Exploration," 2019 IEEE Symposium on Security and Privacy (SP), 2019, pp. 818-834, doi: 10.1109/SP.2019.00035.

SUMMARY: File systems are one of the most basic services of an OS. Most conventional file systems run in the kernel, and hence can lead to devastating errors when bugs are found. However, file systems are large and complex, and coventional stress-testing frameworks either do not scale well (i.e., model checking) or only consider file system regression. Fuzz testing of file systems is gaining traction, but file systems present unique challenges that differ from typical binary fuzzing. Namely, fuzzing a file system consists of mutating a mounted disk image and a program that makes file operations on that image. In this paper, the authors propose Janus, an evolutionary feedback-driven file system fuzzer. When mutating a seed disk image, Janus only mutates the metadata blocks of the image, which reduces the search space of the input. When mutating the file ops program, Janus uses an image-directed syscall fuzzing technique, i.e., it stores generated system calls on file objects and tracks their runtime status after each system call is executed. Moreover, Janus utilizes a libOS executor, i.e., Linux Kernel Library, as opposed to a VM for mounting an image and executing the program; this improves performance and enhances bug reproducibility. Janus found 90 bugs, including 32 CVEs, across 8 popular Linux file systems.

<hr/>

H. Peng, Y. Shoshitaishvili and M. Payer, "T-Fuzz: Fuzzing by Program Transformation," 2018 IEEE Symposium on Security and Privacy (SP), 2018, pp. 697-710, doi: 10.1109/SP.2018.00056.

SUMMARY: Mutational fuzzing is limited by its coverage. Programs may contain complex sanity checks, e.g., checksums, hashes, or magic values, which severely limit code coverage. In this paper, the authors propose Transformational Fuzzing, and a prototype called T-Fuzz. When the fuzzer gets stuck on some sanity check in the program, the fuzzer invokes a program transformer that detects and removes the sanity check from the program. This allows the fuzzer to explore the code paths that were previously protected by those checks. If bugs are found, then a post-processing symbolic execution-based analysis is used which removes false positives. T-Fuzz found bugs in 166 binaries out of 296 in the DARPA CGC dataset, and it found 3 new bugs in real-world applications.

<hr/>

W. You et al., "ProFuzzer: On-the-fly Input Type Probing for Better Zero-Day Vulnerability Discovery," 2019 IEEE Symposium on Security and Privacy (SP), 2019, pp. 769-786, doi: 10.1109/SP.2019.00057.

SUMMARY: Generation-based fuzzing relies on a grammar describing input formats to produce legimite test cases. On the one hand, this reduces the search space for crafting inputs. On the other hand, the grammar must be supplied beforehand or executed from input traces, and vulnerable inputs may not follow the grammar if an implementation ignores certain fields. Meanwhile, mutation-based fuzzing requires seed inputs, requiring no grammar; however, mutation is typically random. In this paper, this authors propose ProFuzzer, which uses a lightweight fuzzing procedure called probing that guides evolution of seed inputs. Specifically, the fuzzer executes in two stages: 1) bytes are sequentially changed one at a time to test the execution path against different values, and data fields are recovered; 2) the fuzzer mutates each field to increase coverage and exploit bad field values. The authors define six application-agnostic field types: 1) assertion (magic byte); 2) raw data (does not affect program execution); 3) enumeration (small set of valid values); 4) loop count (number of times a loop structure executes); 5) offset (locate in the input where the program can access data); 6) size (the size of data to read). ProFuzzer found 42 zero-days among 10 programs, generating 30 CVEs.

<hr/>

S. Gan et al., "CollAFL: Path Sensitive Fuzzing," 2018 IEEE Symposium on Security and Privacy (SP), 2018, pp. 679-696, doi: 10.1109/SP.2018.00040.

SUMMARY: Popular coverage-guided fuzzers suffer from two issues. First, in fuzzers which track edge coverage, edge collisions are a known problem due to the way that edge coverage is calculated; in some applications, up to 75% of edges may collide with others. Second, fuzzers rarely utilize code coverage information to directly drive fuzzing towards non-explored paths. In this paper, the authors propose CollAFL, which rectifies these issues. To solve the edge collision problem, CollAFL analyzes the control flow graph of the application to get a list of known edges, and employs a edge hash scheme with low instrumentation cost and zero collisions. To target non-explored paths, CollAFL proposes three new seed selection policied: 1) untouched-neighbor-branch guided (prioritize seeds with more untouched neighbors); 2) untouched-neighbor-descendant guided (prioritize seeds with untouched neighbors that have more descendants); 3) memory-access guided policy (prioritize seeds with more memory access operations). When compared to AFL, CollAFL covered 20% more program paths, 320% more unique crashes, and 260% more bugs in the LAVA-M dataset. CollAFL also found 157 bugs in 24 applications, generating 95 CVEs.

<hr/>
